1.String date转LocalDateTime
DateUtil.parseLocalDateTime(String date);

2.异常类
BizAssert ApiResultFailEnum

3.LocalDateTime转Date
Date.from(now.atZone(ZoneId.systemDefault()).toInstant());
date转LocalDateTime
date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();

4.图像地址
ImageUtil.getImageUrl(orderSku.getSkuImgUri(), orderSku.getSkuImgUriType());

5.分转元，返回字符串
NumberUtil.intToBigDecimal(Integer number);
PriceUtil.fenToYuanStrTrailingZeros(long fenNum);

6.编程式事物作用代码块上，更颗粒化。
@Autowired
private TransactionTemplate transactionTemplate;
transactionTemplate.execute(transactionStatus -> {return Boolean.TRUE;});

7.LocalDateTime转String
DateUtil.formatLocalDateTime();
LocalDateTimeUtil.formatNormal();
 String转LocalDateTime
LocalDateTimeUtil.parse(time, "yyyy-MM-dd")

8.加密字符串16进制
SecureUtils.encryptStr(String content);

9.解密为字符串
SecureUtils.decryptStr(String content);

10.字符串忽略大小写
"a".equalsIgnoreCase("A");

11. redis工具类
@Resource
private JedisHelper jedisHelper;

12 阿里的JetCache分布式缓存redis锁 非阻塞获取锁
@CreateCache(name = "orderInfoPayTimeExpired:")
private Cache<String, String> orderInfoPayTimeExpiredCache;
orderInfoPayTimeExpiredCache.tryLockAndRun(K key, long expire, TimeUnit timeUnit, () -> {
});

13.空分页
PageDto.emptyPage();

14.判断集合是否为空
CollUtil.isNotEmpty();

15. 根据经纬度获取地址以及地势编码
http://api.map.baidu.com/geocoder?location=24.900957,118.601253&output=json

16. 字符串格式化
StrFormatter.format()

17. alibaba.fastjson格式化对象
JSON.parseObject(response, new TypeReference<ManagerResult<QueryOrderResultDto>>(){});

19. 根据时间天数计算当前之前的时间
LocalDate today = LocalDate.now();
LocalDate nextWeek = today.minus(90, ChronoUnit.DAYS);

20. 根据时间天数计算当前之后的时间
LocalDate today = LocalDate.now();
LocalDate nextWeek = today.plus(90, ChronoUnit.DAYS);

21. 百度地图根据GPS标准坐标(相对于比较准确)
http://api.map.baidu.com/reverse_geocoding/v3/?ak=iRedamZb8fqsESK2NGO0ecpQKxLZ2GUZ&output=json&coordtype=wgs84ll&location=31.325108,120.72347

22. new对象直接设置值
@Accessors(chain = true)

23. 获取客户端ip地址
HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
ServletUtil.getClientIP(request)

24. hutool HttpRequest发送请求工具类
HashMap<String, Object> paramMap = new HashMap<>();
paramMap.put("token", token);
HttpRequest.post(USER_URL)
.header(Header.CONTENT_TYPE, "application/x-www-form-urlencoded")
.form(paramMap)
.execute()
.body();

JSONObject json = new JSONObject();
json.put("username", "1332788xxxxxx");
json.put("password", "123456.");
HttpRequest.post(USER_URL)
.header(Header.CONTENT_TYPE, "application/json")
.body(json)
.execute()
.body();

25. hutool HttpUtil请求
HttpResponse response = HttpUtil.createGet(url).execute().body();

26. list根据3000拆分
Lists.partition(list, 3000);

27. list转map
list.stream().collect(Collectors.toMap(Person::getId, Person::getName,(key1 , key2)-> key2 ));
list.stream().collect(Collectors.groupingBy(ProductRealSaleDto::getCateId));

28. hutool获取时间戳到秒
SignUtil.createNonceStr();

29. 根据关键字显示后10行数据：grep -A 10 关键字  文件

30. 根据关键字显示前10行数据：grep -B 10 关键字  文件

31. cat 文件 | grep 关键字或grep '关键字' 文件

32.mybatis-plus修改忽略值判断
@TableField(value = "end_time", updateStrategy = FieldStrategy.IGNORED)

33.mybatis-plus排除数据库字段
@TableField(exist = false) 

34. list转string
String.join(",", list);

35. list求和
list.stream().mapToInt(student::getScore).sum();

36.string转list
Arrays.asList(str.split(",")).stream().map(s -> (s.trim())).collect(Collectors.toList());

37. startTime <= now, endTime >= now
active.getStartTime().isBefore(now) && active.getEndTime().isAfter(now)

38. 实时更新nacos配置参数
@RefreshScope

39. swagger使用
@Api(tags = "用户接口")
@ApiOperation(value = "用户列表")

@ApiModel("配送地址")
@ApiModelProperty("地址id")

40. hutool获取客户端ip
ServletUtil.getClientIP(request)

41. linux查看安装目录
whereis nginx

42. linux查看历史使用的命令
history
linux重定向符>, >>
> 为重定向符，会把命令执行的输出内容重定向到指定的文件。>>同样为重定向符，内容会被追加到后面。
例如：nohup java -Xms128m -Xmx256m -jar test.jar --spring.profiles.active=test >>nohup.out &
linux只输出错误信息到日志文件
nohup java -jar yourProject.jar >>test.log >/dev/null 2>log & 
linux什么信息也不要
nohup java -jar yourProject.jar >>test.log >/dev/null 2>&1 &
43. hutool RSA非对称加解密
//加密
RSA rsa = new RSA(null, publicKey);
String encrypt = rsa.encryptBase64("18670346997", KeyType.PublicKey);
//解密
RSA rsa = new RSA(privateKey, null);
rsa.decryptStr(encrypt, KeyType.PrivateKey);

44. hutool SHA256算法Base64编码生成签名
Sign sign = SecureUtil.sign(SignAlgorithm.SHA256withRSA, privateKey, null);
String signStr = Base64.getEncoder().encodeToString(sign1.sign("18670346997".getBytes()))

49. fastjson签名顺序错乱的问题 Feature.OrderedField
SortedMap<String, Object> params = JSONObject.parseObject(JSONObject.toJSONString(baseDto), TreeMap.class, Feature.OrderedField);

53. hikari数据源连接池
	springboot2.0默认连接池就是hikari
	配置如下：
spring:
	datasource:
    dynamic:
        primary: supplier
        datasource: 
            supplier:
                url: jdbc:mysql://sztb-test-mysql-3ktsyq.rwlb.rds.aliyuncs.com:3306/test_supplier?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&failOverReadOnly=false&zeroDateTimeBehavior=convertToNull&transformedBitIsBoolean=true&useSSL=false
                username: test_user_j3hp0y
                password: xI8v1VdaJFMGgrfq
                driver-class-name: com.mysql.cj.jdbc.Driver
                type: com.zaxxer.hikari.HikariDataSource
                hikari:
                    minimum-idle: 5
                    maximum-pool-size: 15
                    auto-commit: true
                    idle-timeout: 30000
                    pool-name: DatebookHikariCP
                    max-lifetime: 1800000
                    connection-timeout: 30000
                    connection-test-query: SELECT 1
            pool:
                url: jdbc:mysql://sztb-test-mysql-3ktsyq.rwlb.rds.aliyuncs.com:3306/test_product_pool?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&failOverReadOnly=false&zeroDateTimeBehavior=convertToNull&transformedBitIsBoolean=true&useSSL=false
                username: test_user_j3hp0y
                username: test_user_j3hp0y
                password: xI8v1VdaJFMGgrfq
                driver-class-name: com.mysql.cj.jdbc.Driver
                type: com.zaxxer.hikari.HikariDataSource
                hikari:
                    minimum-idle: 5
                    maximum-pool-size: 15
                    auto-commit: true
                    idle-timeout: 30000
                    pool-name: DatebookHikariCP
                    max-lifetime: 1800000
                    connection-timeout: 30000
                    connection-test-query: SELECT 1
默认使用主数据源，需要切换可以使用@DS("数据源名称")注解切换从数据源。

54. Elasticsearch使用中文分词器 IK分词器。
Springboot集成ElasticSearch有两个客户端去操作
1. ElasticsearchOperations
特点：始终使用面向对象方式操作ES
	索引：用来存放相似文档集合
	映射：用来决定放入文档的每个字段以什么样的方式录入到ES中字段类型 分词器...
	文档：可以被索引最小单元json数据格式
2. RestHighLevelClient 和 kibanna操作一样

45.mybatis-plus or拼接查询
 queryWrapper.and(wrapper -> wrapper.eq(BpLimitAreaSku::getSaleId, 0).or().eq(BpLimitAreaSku::getSaleId, saleId));
 
46.@Transactional失效的几种情况
   a.@Transactional 应用在非 public 修饰的方法上
   b.@Transactional 注解属性 propagation 设置错误
   c.@Transactional 注解属性 rollbackFor 设置错误
   d.同一个类中方法调用，导致@Transactional失效
   e.异常被catch捕获导致@Transactional失效
   本类调用，以最外层事务为准，如果最外层方法没有事务，并且直接this.调用本类的事务方法，将导致事务失效

47.mysql联合索引失效问题
   联合索引是以最左匹配原则并且不能跳过索引中的列(不能出现中间断层)，把经常查询字段的放在最左边。
   
48. mysql执行计划explan类型type执行速度从大到小
	null>system>const>eq_ref>ref>range>index>all

51. mysql判断语句
IF(value IS NOT NULL AND value <> '', value, value1)
IFNULL(SUM(value), 0)
IFNULL(value, value1),if value = null,那么用value1，但不能包括为空的字符串
推荐用IF(value IS NULL OR value = '', value1， value)
SELECT
CASE 
	WHEN value=1 THEN '1'
	WHEN value=0 THEN '0'
END 'value'

CASE 
	value
	WHEN 1 THEN '1'
	WHEN 0 THEN '0'
END 'value'

52. mysql语句 in not in exists not exists
in exists
如果查询的两个表大小相当，那么in和exists差别不大
如果两个表A较小，B较大，小标驱动大表用exists，exists后面连接的子查询返回的是true和false，用于条件验证。
select * from A 
where exists(select 1 from B where cc=A.cc)
如果两个表A较大，B较小，用in
select * from A 
where cc in (select cc from B)

not in not exists
not in 子查询是进行全表扫描，没有用到索引，而not exists的子查询依然能使用到表上的索引
所以无论哪个表大小，用not exists 都比not in要快
select * from A 
where cc not in (select cc from B)
select * from A 
where not exists(select cc from B where cc=A.cc)

50. mysql优化
left join(左连接)：返回包括左表中的所有记录和右表中联结字段相等的记录 
inner join(内连接)：只返回两个表中联结字段相等的行
inner join > left join
select,update > insert,delete
left join on 后面加 and 条件，左边的表数据照样返回，右边会根据条件进行筛选，没有则返回null，按理说速度会大于where，在where之前执行
sql语句执行顺序
FROM > JOIN ON AND > WHERE > GROUP BY > HAVING > SELECT > DISTINCT > ORDER BY > LIMIT

55. mysql explan
1)id：id代表表的加载顺序，id值相同，从上往下执行；id不同，大的最先执行。

2)select_type: select_type代表查询类型，比如：simple、primary、subquery、derived、union、union_result

3)table: 代表哪张表

4)type：代表访问类型排列 
system>const>eq_ref>ref>range>index>ALL
日常查询至少保证达到range级别，最好能达到ref。
system：代表只有一条记录的表，比如系统表，基本上不会出现。
const：表示通过索引一次就能找到的，const用于主键(primary key)、唯一索引(unique key)。因为只匹配一行数据，所以很快。
如将主键置于where列表中，MYSQL就能将该查询转换为一个常量。
eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描
ref：非唯一性索引扫描，返回匹配某个单独值得所有行。本质上也是一种索引访问，它返回所有匹配某个单独值得行，
然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。
range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引
一般就是在你的where语句中出现了between and、<、>、in等的查询这种范围扫描要比全表扫描要好，因为他只需要开始
于索引的某一点，而结束于另一点，不用扫描全部。
index：全索引扫描，index与all区别为index类型只遍历索引树。这通常比all快，因为索引文件通常比数据文件小。
(也就是说all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的。)
all：全表扫描。

5)possible_keys：显示可能应用在这张表中的索引，一个或多个。
查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用

6)key：显示实际使用的索引。

7)key_len：表示索引中使用的字节数，可以通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。
key_len显示的值为索引字段的最大可能的长度

8)ref：显示索引的哪一列被使用，有可能是常数。哪些列或常量被用于查找索引列上的值

9)rows：返回大概找到所需的记录

10)Extra：额外信息，比如：using where、using index等
using filesort：mysql没有使用索引进行排序，产生文件内排序。
using temporary：使用临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组group by。
using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错。
如果同时出现using where，表明索引被用来执行索引键值的查找；
如果没有出现using where，表明索引用来读取数据而非执行查询动作。

56.索引失效
1).复合索引要遵循最左匹配原则，并且不能跳过索引中的列(不能出现中间断层)
2).不能在索引列上做任何操作（计算、函数、类型转换等），会导致索引失效而转向全表扫描。
3).尽可能的使用覆盖索引(只访问索引列的查询（索引列和查询列一致)），减少select * 的使用。
4).低版本mysql在使用不等于（!=或者<>）的时候无法使用索引会导致全表扫描，高版本mysql会使用索引并且是范围(range)查找
5).低版本mysql在使用is not null是无法使用索引，高版本mysql会使用索引并且是范围(range)查找。is null是可以使用索引的。
6).少用or，用它来连接时会导致索引失效
7).字符串不加单引号也会导致索引失效。
8).sql语句模糊查询的时候左右两边都使用了通配符%号会导致索引失效，解决办法1：左边的通配符%去掉2：使用覆盖索引。
group by 分组之前必排序，会有临时表

57.mysql日志
1). 重做日志(redo log): 确保事物的持久性。redo日志记录事务执行后的状态，用来恢复写入data file的
已成功事物更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，再重启mysql服务的时候，根据redo log
进行重做，从而达到事物的持久性。
2).回滚日志(undo log)：保证数据的原子性，保存了事物发生之前的数据的一个版本也就是未提交事物的数据，可以用于回滚。
3).二进制日志(binlog)：记录事物提交的数据，用于复制，在主从复制中，从库利用主库上的binlog进行复制，实现主从同步。
4).错误日志(errorlog)：错误日志记录着mysqld启动和停止，以及服务器在运行过程中发生的错误的相关信息。
5).慢查询日志(slow query log)：慢查询日志记录执行时间过长和没有使用索引的查询语句。慢日志只会记录执行成功的语句。
默认执行时间大于10s会被记录。
6).一般查询日志(general log)：一般查询日志记录了服务器接收到的每一个查询或是命令，无论这些查询还是命令是否正确或者错误，
general log都会将其记录下来。
7).中继日志(relay log)：从数据库服务器启动I/O将主服务器的bin log日志读取过来记录到relay log里面，然后从服务器sql线程读取relay log
之日的内容并应用到服务器上，从而达到主从服务器数据的一致。

58.mysql优化步骤
1).用慢查询日志捕获查询时间长的sql
2).用explan分析耗时长的sql
3).sql数据库服务器的参数调优

59.索引优化分析
1).使用索引
2).单表查询优化：复合索引要遵循最左匹配原则。
3).关联查询优化：保证被关联表连接的字段建立索引。
4).子查询优化:in和exists使用，小表驱动大表使用exists否则使用in
5).order by 关键字优化：尽量使用Index方式排序,避免使用FileSort方式排序，复合索引要遵循最左匹配原则，对应字段升降序要一致。
6).分页查询优化
7).group by关键字优化：group by 实质是先排序后分组，复合索引要遵循最左匹配原则。
当无法使用索引时，可以增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置
where高于having，能使用where就不要使用having。
8).去重优化：尽量不适用distinct，可以使用group by分组达去重。

60.查询截取分析
1).开启慢查询日志，SHOW VARIABLES LIKE '%slow_query_log%';查询是否开启，set global slow_query_log=1;设置开启。
根据慢查询日志找到耗时较长的sql。
2).用show profile去分析，首先要开启show profile功能Show  variables like 'profiling';查看状态，set profiling=1;设置开启，
然后用show profiles查看结果，会显示最近查询前15条sql语句，找到其中耗时最长的语句，在使用show profile cpu,block io for query n分析sql语句在
各个过程中所消耗时间和性能，逐一去排查。如果sql语句建立连接，校验权限，语句优化，执行时间等各个阶段。	
3).开启全局查询日志set global general_log=1;命令开启，set global log_output='TABLE';使用的sql语句就会记录在mysql.general_log表里。

70.表锁(偏读)
偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
mysql表锁两种模式：读锁（共享锁）、写锁（排它锁）
读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞。

71.行锁(偏写)
偏向Innodb存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
Innodb与MyISAM的最大不同有两点：一是支持事物；二是采用了行级锁。
无索引会导致行锁升级到表锁。
间隙锁是指范围性锁。

72.mysql主从复制两种方式，三种模式
第一种方式基于二进制日志进行复制。
原理如下：
1)master将改变的记录保存到二进制日志(bin log)中
2)slave的io线程连接master并获取二进制日志内容写入到自己的中继日志(relay log)中
3)slave的sql线程读取中继日志(relay log)中改变的记录并执行，让数据与master数据保持一致。
主从复制默认使用异步模式

第二种方式：基于gtid方式进行复制，对MySQL版本有要求，最好5.7版本以上。
gtid(global transation id)是全局事务ID由两部分组成：server_uuid和transaction_id。
server_uuid代表MySQL实例的唯一标识。
transaction_id代表该实例上已提交的事务数量。
原理如下：
1)master更新数据时，会在事务前产生GTID，一同记录到binlog日志中。
2)slave端的i/o线程将变更的binlog，写入到本地的relay log中。
3)sql线程从relay log中获取GTID，然后对比slave端的binlog是否有记录。
4)如果有记录，说明该GTID的事务已经执行，slave会忽略。
5)如果没有记录，slave就会从relay log中执行该GTID的事务，并记录到binlog。
6)在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有就用全部扫描。
GTID的优点：
1)一个事务对应一个唯一ID，一个GTID在一个服务器上只会执行一次。
2)GTID是用来代替传统的复制方法，GTID复制与普通复制模式最大的不同就是不需要指定二级制文件名和位置
3)减少手工干预和降低服务故障时间，当主机挂了之后通过软件从众多的备机中提升一台备机为主机。
GTID复制默认使用异步模式。
三种模式
异步模式：主库在执行完客户端提交的事务后会立即将结果返给客户端，并不关心从库是否已经接受并处理。
这样会有一个问题，主库挂掉，此时主库上已经提交事务，可能并没有传到从库上，如果此时，强行将从提升为主，
可能导致新主上的数据不完整。

同步模式：当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回。
导致时间长，性能低。

半同步模式：介于同步复制与异步复制之间的一种，主库只需要等待至少一个从库节点收到，只需要从库I/O线程执行到中继日志完成即可，
主库不需要等待所有从库给主库反馈。节省了很多时间。（需要添加插件才能使用）

73.mycat作用
读写分离、数据分片、多数据源整合

74.mysql数据库分区
表的使用不受影响，还是一张表，体现在物理存储的文件上，原本一个表对应一个文件，分区之后一张表对应多个文件。
4种分区类型
range分区：根据表字段的范围进行分区，比如年份范围。
list分区：集合分区，指定具体数据进行分区，如果年份 2001,2002；2003,2004。
hash分区：根据hash算法进行分区，比如求余数。
子分区：结合上三种进行分区，比如先设置range分区，在range分区在设置子分区hash分区。
分区优点：提高查询速度。
分区缺点：并发量不高，分区键设置不灵活。

75.mysql数据库查询过程
1).客户端向mysql服务器发送一条查询请求
2).服务器首先检查查询缓存，如果命中缓存，则立即返回存储在缓存中的结果，否则进入下一个阶段
3).服务器进行SQL解析、预处理、再由优化器生成对应的执行计划。
4).mysql根据执行计划，调用存储引擎的API来执行查询
5).将结果返回给客户端，同时缓存查询结果

76.mysql数据库垂直拆分、水平拆分。
垂直拆分：把不同的表拆到不同的数据库中。按照业务将表进行分类，分布到不同的数据库上面，这样也就将压力分担到不同的数据库上。
例如：电商项目，会把用户相关表的放在一个库中，商品相关的表放在一个库中，业务交易相关的表放在一个库等。
垂直拆分优点：1.拆分后业务清晰，拆分规则明确。2.系统之间整合或扩展容易。3.数据库维护简单。
垂直拆分缺点：1.部分业务无法join关联，只能通过接口的方式去解决，提高了系统的复杂度。
2.事物处理复杂。
水平拆分：把同一个表拆分到不同的数据库中，按照数据行进行切分。
水平拆分优点：拆分规则抽象好，join操作基本可以数据库做；不存在单库大数据，高并发的性能瓶颈；
应用端改造较少；提高了系统的稳定性跟负载能力。
水平拆分缺点：拆分规则难以抽象；分片事务一致性难以解决；数据多次扩展难度跟维护量极大；跨库join性能较差。

77.mysql事物的四大特性(ACID)
1).原子性(Atomicity):事物在操作的时候要么成功，要么失败。
2).一致性(Consistency):事物在执行前后，数据都是保持一致的。
3).隔离性(Isolation):指多个事物并发执行的时候，事物内部的操作与其他事物是隔离的，各个事物之间不能相互干扰。
4).持久性(Durability):事物一旦提交，数据永久生效，不会改变。
mysql怎么保证一致性呢？
数据库通过原子性、隔离性、持久性来保证一致性。一致性是目的，原子性、隔离性、持久性是手段。通过手段来保证目的。
比如：原子性无法保证，显然一致性也无法保证。
mysql怎么保证原子性呢？
利用Innodb的undo log。undo log名为回滚日志，是实现原子性的关键，当事物回滚时能够撤销所有成功执行的sql语句，
他需要记录你要回滚的相应日志信息。
比如：
(1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
(2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作
(3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作
mysql怎么保证持久性呢？
利用Innodb的redo log。redo log名为重做日志，是实现持久性的关键。Mysql是先把磁盘上的数据加载到内存中，
在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。
于是，决定采用redo log解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。
当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，
会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。
mysql怎么保证隔离性呢？
利用表锁和行锁来实现隔离性。
78.Jenkins
持续集成工具
启动jenkins并指定端口
nohup java -jar jenkins.war --httpPort=8845
nexus3：Maven仓库管理器
79.mysql隔离级别
1).读未提交：脏读、不可重复读、幻读
2).读已提交：不可重复读、幻读
3).可重复读：幻读
4).可串行化
mysql默认隔离级别：可重复读
脏读：读取到其它事物未提交的数据。
不可重复：读取到其它事物已修改过的数据。
幻读：读取到其它事务已新增的数据。

79.数据结构及算法
1).数据结构包括：线性结构和非线性结构
线性结构：线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系；
线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的；
链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息；
线性结构常见的有：数组、队列、链表和栈。
非线性结构：一对多的关系比如：树结构、图结构等。
2).冒泡排序算法:外循环控制轮数，内循环每轮的次数。
3).二分查找算法：查找的数据是有序排列，会将数据分为三个部分，左，中，右。
查找的数据大于中间数据，则从右边找；查找的数据小于中间数据，则从左边找；否则相等，
查找方式使用递归或循环的方式。
4).单向链表：查找的方向只能是一个方向，单向链表不能自我删除，需要依靠辅助节点。next指向下一个节点。
5).双向链表：可以向前或向后查找，可以自我删除。next指向下一个节点，pre指向前一个节点。
6).二叉树：每个节点最多只能有两个子节点，子节点分为左节点和右节点。
   满二叉树：如果该二叉树的所有叶子节点都在最后一层，并且节点总数=2^n-1,n为层数。满二叉树也是完全二叉树的一种。
   完全二叉树：如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，
   倒数第二层的叶子节点在右边连续，我们称为完全二叉树。
二叉树有三种遍历方式：
第一种前序遍历：先输出父节点，在遍历左子树和右子树
第二种中序遍历：先遍历左子树，只输出父节点，在遍历右子树
第三种后序遍历：先遍历左子树，在遍历右子树，最后输出父节点
7).堆
堆是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值，
称为大顶堆。
每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆
8).二叉查找树或二叉排序树(Binary sort(search) tree)
二叉查找树：对于二叉查找树的任何一个非叶子节点，要求左子节点的值比当前节点值小，
右子节点的值比当前节点的值大。如果相等的值，可以将该节点放在左子节点或右子节点。








